<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>转载-java反射 | FireWatcher's Study Blog</title><meta name="description" content="java反射的相关问题"><meta name="keywords" content="转载"><meta name="author" content="Zhu Lang"><meta name="copyright" content="Zhu Lang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/assets/pika.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><meta name="twitter:card" content="summary"><meta name="twitter:title" content="转载-java反射"><meta name="twitter:description" content="java反射的相关问题"><meta name="twitter:image" content="http://yoursite.com/assets/java.jpg"><meta property="og:type" content="article"><meta property="og:title" content="转载-java反射"><meta property="og:url" content="http://yoursite.com/2020/03/31/%E8%BD%AC%E8%BD%BD-java%E5%8F%8D%E5%B0%84/"><meta property="og:site_name" content="FireWatcher's Study Blog"><meta property="og:description" content="java反射的相关问题"><meta property="og:image" content="http://yoursite.com/assets/java.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/03/31/%E8%BD%AC%E8%BD%BD-java%E5%8F%8D%E5%B0%84/"><link rel="next" title="转载-java干货总结" href="http://yoursite.com/2020/03/30/%E8%BD%AC%E8%BD%BD-java%E5%B9%B2%E8%B4%A7%E6%80%BB%E7%BB%93/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">FireWatcher's Study Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/assets/pika.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">1</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/assets/java.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">转载-java反射</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-31<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-31</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><p>本文转子微信公众号“java技术江湖“，相关文章及其仓库<a href="https://github.com/h2pl/Java-Tutorial" target="_blank" rel="noopener">https://github.com/h2pl/Java-Tutorial</a></p>
<p><strong>什么是反射</strong><br>反射是java语言开发特征之一，允许java程序在运行的时候获取自身的信息，并且可以操作类或对象的内部属性。</p>
<p><strong>反射的用途</strong><br>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。反射最重要的用途就是开发各种通用框架。<br>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p>
<p><strong>什么是Class类</strong><br>1、Class是一个类，一个描述类的类（也就是描述类本身），封装了描述方法的Method，描述字段的Filed，描述构造器的Constructor等属性。<br>2、对象照镜子后（反射）可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。<br>3、对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个Class对象包含了特定某个类的有关信息。<br>4、Class 对象只能由系统建立对象<br>5、一个类在 JVM 中只会有一个Class实例</p>
<p><strong>反射的应用</strong><br>获取class的方法有三种：<br>(1)使用Class类的forName静态方法:</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Class<!--?--> forName(String className)</span><br><span class="line">//在JDBC开发中常用此方法加载数据库驱动:</span><br><span class="line">//要使用全类名来加载这个类，一般数据库驱动的配置信息会写在配置文件中。加载这个驱动前要先导入jar包</span><br><span class="line"> Class.forName(driver);</span><br></pre></td></tr></tbody></table></figure></div>

<p>(2)直接获取某一个对象的class，比如:</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Class<!--?-->是一个泛型表示，用于获取一个类的类型。</span><br><span class="line">Class<!--?--> klass = int.class;</span><br><span class="line">Class<!--?--> classInt = Integer.TYPE;</span><br></pre></td></tr></tbody></table></figure></div>

<p>(3)调用某个对象的getClass()方法,比如:</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = new StringBuilder("123");</span><br><span class="line">Class<!--?--> klass = str.getClass();</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>判断是否为某个类的实例</strong><br>一般地，我们用instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断是否为某个类的实例，它是一个Native方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native boolean isInstance(Object obj);</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>创建实例</strong><br>（1）使用Class对象的newInstance()方法来创建Class对象对应类的实例。<br>注意：利用newInstance创建对象：调用的类必须有无参的构造器</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Class<!--?-->代表任何类的一个类对象。</span><br><span class="line">//使用这个类对象可以为其他类进行实例化</span><br><span class="line">//因为jvm加载类以后自动在堆区生成一个对应的*.Class对象</span><br><span class="line">//该对象用于让JVM对进行所有*对象实例化。</span><br><span class="line">Class<!--?--> c = String.class;</span><br><span class="line"></span><br><span class="line">//Class<!--?--> 中的 ? 是通配符，其实就是表示任意符合泛类定义条件的类，和直接使用 Class</span><br><span class="line">//效果基本一致，但是这样写更加规范，在某些类型转换时可以避免不必要的 unchecked 错误。</span><br><span class="line"></span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></tbody></table></figure></div>

<p>（2）先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获取String所对应的Class对象</span><br><span class="line">Class<!--?--> c = String.class;</span><br><span class="line">//获取String类带一个String参数的构造器</span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line">//根据构造器创建实例</span><br><span class="line">Object obj = constructor.newInstance("23333");</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>获取方法</strong><br>获取某个Class对象的方法集合，主要有以下几个方法：<br>getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Method[] getDeclaredMethods() throws SecurityException</span><br></pre></td></tr></tbody></table></figure></div>

<p>getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Method[] getMethods() throws SecurityException</span><br></pre></td></tr></tbody></table></figure></div>

<p>getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Method getMethod(String name, Class<!--?-->... parameterTypes)</span><br></pre></td></tr></tbody></table></figure></div>

<p>只是这样描述的话可能难以理解，我们用例子来理解这三个方法：本文中的例子用到了以下这些类，用于反射的测试。</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//注解类，可用于表示方法，可以通过反射获取注解的内容。</span><br><span class="line">//Java注解的实现是很多注框架实现注解配置的基础</span><br><span class="line">//@interface 不是interface，是注解类  定义注解</span><br><span class="line">//@Target表示注解的作用目标</span><br><span class="line">//注解@Retention可以用来修饰注解，是注解的注解，称为元注解。</span><br><span class="line">@Target(ElementType.METHOD) </span><br><span class="line">@Retention(RetentionPolicy.RUNTIME) </span><br><span class="line">public @interface Invoke {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>userbean的父类personbean</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PersonBean {</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">int id;</span><br><span class="line"></span><br><span class="line">public String getName() {</span><br><span class="line">    return name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public void setName(String name) {</span><br><span class="line">    this.name = name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>}</p>
<p>接口user</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface User {</span><br><span class="line">    public void login ();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>userBean实现user接口，继承personbean</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class UserBean extends PersonBean implements User{</span><br><span class="line">    @Override</span><br><span class="line">    public void login() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    class B {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String userName;</span><br><span class="line">    protected int i;</span><br><span class="line">    static int j;</span><br><span class="line">    private int l;</span><br><span class="line">    private long userId;</span><br><span class="line">    public UserBean(String userName, long userId) {</span><br><span class="line">        this.userName = userName;</span><br><span class="line">        this.userId = userId;</span><br><span class="line">    }</span><br><span class="line">    public String getName() {</span><br><span class="line">        return userName;</span><br><span class="line">    }</span><br><span class="line">    public long getId() {</span><br><span class="line">        return userId;</span><br><span class="line">    }</span><br><span class="line">    @Invoke</span><br><span class="line">    public static void staticMethod(String devName,int a) {</span><br><span class="line">        System.out.printf("Hi %s, I'm a static method", devName);</span><br><span class="line">    }</span><br><span class="line">    @Invoke</span><br><span class="line">    public void publicMethod() {</span><br><span class="line">        System.out.println("I'm a public method");</span><br><span class="line">    }</span><br><span class="line">    @Invoke</span><br><span class="line">    private void privateMethod() {</span><br><span class="line">        System.out.println("I'm a private method");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>1 getMethods和getDeclaredMethods的区别</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class 动态加载类的反射 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        try {</span><br><span class="line">            Class clazz = Class.forName("com.javase.反射.UserBean");</span><br><span class="line">            for (Field field : clazz.getDeclaredFields()) {</span><br><span class="line">//                field.setAccessible(true);</span><br><span class="line">                System.out.println(field);</span><br><span class="line">            }</span><br><span class="line">            //getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。</span><br><span class="line">            System.out.println("------共有方法------");</span><br><span class="line">//        getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。</span><br><span class="line">//            getMethod*()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。</span><br><span class="line">            for (Method method : clazz.getMethods()) {</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                //打印出了UserBean.java的所有方法以及父类的方法</span><br><span class="line">            }</span><br><span class="line">            System.out.println("------独占方法------");</span><br><span class="line"></span><br><span class="line">            for (Method method : clazz.getDeclaredMethods()) {</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            }</span><br><span class="line">        } catch (ClassNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>2 打印一个类的所有方法及详细信息：</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class 打印所有方法 {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Class userBeanClass = UserBean.class;</span><br><span class="line">        Field[] fields = userBeanClass.getDeclaredFields();</span><br><span class="line">        //注意，打印方法时无法得到局部变量的名称，因为jvm只知道它的类型</span><br><span class="line">        Method[] methods = userBeanClass.getDeclaredMethods();</span><br><span class="line">        for (Method method : methods) {</span><br><span class="line">            //依次获得方法的修饰符，返回类型和名称，外加方法中的参数</span><br><span class="line">            String methodString = Modifier.toString(method.getModifiers()) + " " ; // private static</span><br><span class="line">            methodString += method.getReturnType().getSimpleName() + " "; // void</span><br><span class="line">            methodString += method.getName() + "("; // staticMethod</span><br><span class="line">            Class[] parameters = method.getParameterTypes();</span><br><span class="line">            Parameter[] p = method.getParameters();</span><br><span class="line"></span><br><span class="line">            for (Class parameter : parameters) {</span><br><span class="line">                methodString += parameter.getSimpleName() + " " ; // String</span><br><span class="line">            }</span><br><span class="line">            methodString += ")";</span><br><span class="line">            System.out.println(methodString);</span><br><span class="line">        }</span><br><span class="line">        //注意方法只能获取到其类型，拿不到变量名</span><br><span class="line">/*        public String getName()</span><br><span class="line">        public long getId()</span><br><span class="line">        public static void staticMethod(String int )</span><br><span class="line">        public void publicMethod()</span><br><span class="line">        private void privateMethod()*/</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>获取构造器方法</strong><br>获取类构造器的用法与上述获取方法的用法类似。主要是通过Class类的getConstructor方法得到Constructor类的一个实例，而Constructor类有一个newInstance方法可以创建一个对象实例:</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class 打印构造方法 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        // constructors</span><br><span class="line">        Class<!--?--> clazz = UserBean.class;</span><br><span class="line"></span><br><span class="line">        Class userBeanClass = UserBean.class;</span><br><span class="line">        //获得所有的构造方法</span><br><span class="line">        Constructor[] constructors = userBeanClass.getDeclaredConstructors();</span><br><span class="line">        for (Constructor constructor : constructors) {</span><br><span class="line">            String s = Modifier.toString(constructor.getModifiers()) + " ";</span><br><span class="line">            s += constructor.getName() + "(";</span><br><span class="line">            //构造方法的参数类型</span><br><span class="line">            Class[] parameters = constructor.getParameterTypes();</span><br><span class="line">            for (Class parameter : parameters) {</span><br><span class="line">                s += parameter.getSimpleName() + ", ";</span><br><span class="line">            }</span><br><span class="line">            s += ")";</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            //打印结果//public com.javase.反射.UserBean(String, long, )</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>获取类的成员变量（字段）信息</strong><br>主要是这几个方法，在此不再赘述：<br>getFiled: 访问公有的成员变量<br>getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量<br>getFileds和getDeclaredFields用法同上（参照Method）</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class 打印成员变量 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Class userBeanClass = UserBean.class;</span><br><span class="line">        //获得该类的所有成员变量，包括static private</span><br><span class="line">        Field[] fields = userBeanClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        for(Field field : fields) {</span><br><span class="line">            //private属性即使不用下面这个语句也可以访问</span><br><span class="line">//            field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">            //因为类的私有域在反射中默认可访问，所以flag默认为true。</span><br><span class="line">            String fieldString = "";</span><br><span class="line">            fieldString += Modifier.toString(field.getModifiers()) + " "; // `private`</span><br><span class="line">            fieldString += field.getType().getSimpleName() + " "; // `String`</span><br><span class="line">            fieldString += field.getName(); // `userName`</span><br><span class="line">            fieldString += ";";</span><br><span class="line">            System.out.println(fieldString);</span><br><span class="line">            </span><br><span class="line">            //打印结果</span><br><span class="line">//            public String userName;</span><br><span class="line">//            protected int i;</span><br><span class="line">//            static int j;</span><br><span class="line">//            private int l;</span><br><span class="line">//            private long userId;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>调用方法</strong><br>当我们从类中获取了一个方法后，我们就可以用invoke()方法来调用这个方法。invoke方法的原型为:</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">        throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br><span class="line">       </span><br><span class="line">public class 使用反射调用方法 {</span><br><span class="line">    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException {</span><br><span class="line">        Class userBeanClass = UserBean.class;</span><br><span class="line">        //获取该类所有的方法，包括静态方法，实例方法。</span><br><span class="line">        //此处也包括了私有方法，只不过私有方法在用invoke访问之前要设置访问权限</span><br><span class="line">        //也就是使用setAccessible使方法可访问，否则会抛出异常</span><br><span class="line">//       // IllegalAccessException的解释是</span><br><span class="line">//        * An IllegalAccessException is thrown when an application tries</span><br><span class="line">// * to reflectively create an instance (other than an array),</span><br><span class="line">// * set or get a field, or invoke a method, but the currently</span><br><span class="line">// * executing method does not have access to the definition of</span><br><span class="line">// * the specified class, field, method or constructor.</span><br><span class="line"></span><br><span class="line">//        getDeclaredMethod*()获取的是类自身声明的所有方法，包含public、protected和private方法。</span><br><span class="line">//            getMethod*()获取的是类的所有共有方法，这就包括自身的所有public方法，和从基类继承的、从接口实现的所有public方法。</span><br><span class="line"></span><br><span class="line">        //就是说，当这个类，域或者方法被设为私有访问，使用反射调用但是却没有权限时会抛出异常。</span><br><span class="line">        Method[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法</span><br><span class="line">        for (Method method : methods) {</span><br><span class="line">            //反射可以获取方法上的注解，通过注解来进行判断</span><br><span class="line">            if (method.isAnnotationPresent(Invoke.class)) { // 判断是否被 @Invoke 修饰</span><br><span class="line">                //判断方法的修饰符是是static</span><br><span class="line">                if (Modifier.isStatic(method.getModifiers())) { // 如果是 static 方法</span><br><span class="line">                    //反射调用该方法</span><br><span class="line">                    //类方法可以直接调用，不必先实例化</span><br><span class="line">                    method.invoke(null, "wingjay",2); // 直接调用，并传入需要的参数 devName</span><br><span class="line">                } else {</span><br><span class="line">                    //如果不是类方法，需要先获得一个实例再调用方法</span><br><span class="line">                    //传入构造方法需要的变量类型</span><br><span class="line">                    Class[] params = {String.class, long.class};</span><br><span class="line">                    //获取该类指定类型的构造方法</span><br><span class="line">                    //如果没有这种类型的方法会报错</span><br><span class="line">                    Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数</span><br><span class="line">                    //通过构造方法的实例来进行实例化</span><br><span class="line">                    Object userBean = constructor.newInstance("wingjay", 11); // 利用构造函数进行实例化，得到 Object</span><br><span class="line">                    if (Modifier.isPrivate(method.getModifiers())) {</span><br><span class="line">                        method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限</span><br><span class="line">//                        Set the {@code accessible} flag for this object to</span><br><span class="line">//     * the indicated boolean value.  A value of {@code true} indicates that</span><br><span class="line">//     * the reflected object should suppress Java language access</span><br><span class="line">//     * checking when it is used.  A value of {@code false} indicates</span><br><span class="line">//                                * that the reflected object should enforce Java language access checks.</span><br><span class="line">                        //通过该方法可以设置其可见或者不可见，不仅可以用于方法</span><br><span class="line">                        //后面例子会介绍将其用于成员变量</span><br><span class="line">                                            //打印结果</span><br><span class="line">//            I'm a public method</span><br><span class="line">// Hi wingjay, I'm a static methodI'm a private method</span><br><span class="line">                    }</span><br><span class="line">                    method.invoke(userBean); // 调用 method，无须参数</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><strong>利用反射创建数组</strong><br>数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class 用反射创建数组 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Class<!--?--> cls = null;</span><br><span class="line">        try {</span><br><span class="line">            cls = Class.forName("java.lang.String");</span><br><span class="line">        } catch (ClassNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        Object array = Array.newInstance(cls,25);</span><br><span class="line">        //往数组里添加内容</span><br><span class="line">        Array.set(array,0,"hello");</span><br><span class="line">        Array.set(array,1,"Java");</span><br><span class="line">        Array.set(array,2,"fuck");</span><br><span class="line">        Array.set(array,3,"Scala");</span><br><span class="line">        Array.set(array,4,"Clojure");</span><br><span class="line">        //获取某一项的内容</span><br><span class="line">        System.out.println(Array.get(array,3));</span><br><span class="line">        //Scala</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>其中的Array类为java.lang.reflect.Array类。我们通过Array.newInstance()创建数组对象，它的原型是:</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Object newInstance(Class<!--?--> componentType, int length)</span><br><span class="line">        throws NegativeArraySizeException {</span><br><span class="line">        return newArray(componentType, length);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>

<p>而newArray()方法是一个Native方法，它在Hotspot JVM里的具体实现我们后边再研究，这里先把源码贴出来</p>
<div class="code-area-wrap"><div class="highlight-tools"><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static native Object newArray(Class<!--?--> componentType, int length)</span><br><span class="line">        throws NegativeArraySizeException;</span><br></pre></td></tr></tbody></table></figure></div>



<p><strong>反射常见面试题</strong><br>Q:什么是反射？<br>A:反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<p>Q:哪里用到反射机制？<br>JDBC中，利用反射动态加载了数据库驱动程序。Web服务器中利用反射调用了Sevlet的服务方法。Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。很多框架都用到反射机制，注入属性，调用方法，如Spring。</p>
<p>Q:什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作？<br>对象序列化，将对象中的数据编码为字节序列的过程。反序列化；将对象的编码字节重新反向解码为对象的过程。JAVA提供了API实现了对象的序列化和反序列化的功能，使用这些API时需要遵守如下约定：被序列化的对象类型需要实现序列化接口，此接口是标志接口，没有声明任何的抽象方法，JAVA编译器识别这个接口，自动的为这个类添加序列化和反序列化方法。为了保持序列化过程的稳定，建议在类中添加序列化版本号。不想让字段放在硬盘上就加transient 以下情况需要使用 Java 序列化：想把的内存中的对象状态保存到一个文件中或者数据库中时候；想用套接字在网络上传送对象的时候；想通过RMI（远程方法调用）传输对象的时候。</p>
<p>Q:反射机制的优缺点？<br>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。缺点：对性能有影响，这类操作总是慢于直接执行java代码。</p>
<p>Q:动态代理是什么？有哪些应用？<br>动态代理是运行时动态生成代理类。动态代理的应用有 Spring AOP数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>
<p>Q:怎么实现动态代理？<br>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<p>Q:Java反射机制的作用<br>在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法</p>
<p>Q:如何使用Java的反射?<br>A:1.通过一个全限类名创建一个对象<br>Class.forName(“全限类名”); 例如：com.mysql.jdbc.Driver Driver类已经被加载到 jvm中，并且完成了类的初始化工作就行了 类名.class; 获取Class<？> clz 对象 对象.getClass();<br>2.获取构造器对象，通过构造器new出一个对象Clazz.getConstructor([String.class]);Con.newInstance([参数]);<br>通过class对象创建一个实例对象（就相当与new类名（）无参构造器) Cls.newInstance();<br>3.通过class对象获得一个属性对象<br>Field c=cls.getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。<br>Field c=cls.getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的声明字段<br>4.通过class对象获得一个方法对象<br>Cls.getMethod(“方法名”,class……parameaType);（只能获取公共的）<br>Cls.getDeclareMethod(“方法名”);（获取任意修饰的方法，不能执行私有）<br>M.setAccessible(true);（让私有的方法可以执行） 让方法执行 1）<br>Method.invoke(obj实例对象,obj可变参数);—–（是有返回值的）</p>
</body></html></div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD/">转载    </a></div><div class="post_share"><div class="social-share" data-image="/assets/java.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/03/30/%E8%BD%AC%E8%BD%BD-java%E5%B9%B2%E8%B4%A7%E6%80%BB%E7%BB%93/"><img class="next_cover lazyload" data-src="/assets/java.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>转载-java干货总结</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/30/转载-java干货总结/" title="转载-java干货总结"><img class="relatedPosts_cover lazyload"data-src="/assets/java.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-30</div><div class="relatedPosts_title">转载-java干货总结</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" style="background-image: url(/assets/java.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Zhu Lang</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>